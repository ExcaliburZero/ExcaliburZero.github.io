---
layout: post
type: article
title:  "Developing a Haskell Library"
author: "Christopher Randall Wells"
image: "/images/developing_haskell_library.png"
date:   2016-07-19 09:10:00
categories: haskell library avatars
---
Recently I have been working on getting better at writing code in Haskell, and in doing so I have worked on a few different small libraries and applications. One of the more interesting libraries that I have written in this attempt is [Pixelated Avatar Generator](https://hackage.haskell.org/package/pixelated-avatar-generator).

Pixelated Avatar Generator is a Haskell library that I have been working on, which provides functions for generating and saving pixelated avatars to serve as default user avatars for websites, similar to the ones used by GitHub and Techdirt.

## Starting
To create the initial setup of the library, I used a [custom Stack project template](https://github.com/ExcaliburZero/custom-stack-templates/blob/master/cwells.hsfiles) I put together which includes hspec testing, Travis CI automated testing, and Coveralls.io coverage reports.

From there I started to brainstorm how the library would work. I knew that I wanted a way to be able to generate randomized avatars in a reproducible way that would be easy to test. So I figured that I could set it up so that avatars would be generated by using seed values. That way a random avatar could be generated just by passing in a random seed, while avatars could be reliably generated from given seeds for testing purposes.

In order to work with seed values, I knew that I needed to have some sort of way of standardizing the seed values in order to be able to design an algorithm to use the seed to generate an avatar image. Luckily I had recently watched YouTube user jekor's series on [Haskell From Scratch](https://www.youtube.com/playlist?list=PLxj9UAX4Em-Ij4TKwKvo-SLp-Zbv-hB4B), in which he uses a pure Haskell implementation of an [md5 hash function](https://hackage.haskell.org/package/pureMD5).

Since the md5 hash function can take in a String of a given length and return a 32 digit hexadecimal number, I figured it would be an ideal way to standardize seed values. That way a String could be passed into the md5 function and the seed value would be the resulting standardized number.

~~~
>>> (show . md5 . fromString) "Hello"
"8b1a9953c4611296a827abf8c47804d7"
~~~

## Color Generation
For the avatar images, I decided that each avatar would have a given color from some given set of possible colors. At first I figured that I could make use of the fact that each of the digits in the seed values was hexadecimal, so I decided to have 8 different possible colors.

In order to generate the color I decided to take the first two digits of the seed, average them into one hexadecimal digit, and have each color correspond to two of the possible resulting digits. However, after using ghci to generate a bunch of colors from a list of seeds I found that the statistical distribution of the colors chosen tended to be heavily focused on one specific color. Almost half of the seeds I would feed into the color choosing function I had written would yield orange.[^color-stats]

I only later realized that the issue was caused by an incorrect averaging of the hexadecimal digits, as averaged the values returned using `ord` from `Data.Char` and mapped them to the returned values of `ord` on the hexadecimal digits. The values of `ord '9'` and `ord 'a'` are not next to each other.[^color]

Once I noticed the issue with the uneven distribution of colors I decided to come up with a new algorithm for the color choosing function. The algorithm I ended upcoming up with was to take the first two characters of the seed value, sum their `ord` values, and take the modulus 8 of the resulting number and map the resulting digit 0-7 to a color.[^color-alg-2]

~~~ haskell
colorFromSeed :: Seed -> Color
colorFromSeed = genColor . dSum . unSeed
  where twoDigits n = map ord $ take 2 n
        dSum n = foldr (+) 1 $ twoDigits n
        genColor a = [Black .. Yellow] !! (a `mod` 8)
~~~

## Pattern Generation
Once I had handled color generation for avatars, I decided to move on to generating the pattern for the avatar images. I decided to try to achieve a similar type of pattern to that used by GitHub in its default avatars.[^pattern-type]

![An example of a default GitHub avatar]({{ site.baseurl }}/images/avatar_github.png)

The type of pattern used in default GitHub avatars starts with a 3x5px pattern which is then reflected over the y axis, such that it overlaps in the middle, resulting in a 5x5px pattern.[^github-pattern]

Instead of using a 5x5px pattern, I decided to try creating an 8x8px pattern. I figured that I could create the pattern by generating a 4x4px pattern and then reflecting it over the y-axis without overlap.

I thought that I would be able to create the 4x8px pattern by creating a list of 32 binary values and then converting that into a grid. I noticed that the seed values, being md5 hashes, were 32 digits in length, so I figured that I could just round them each up or down to a False or True value around 7, and then use those boolean values to represent colored and uncolored pixels in the pattern.[^md5-coincidence] [^map-map]

~~~ haskell
numToGrid :: String -> [[Bool]]
numToGrid s = grid
  where grid = (map . map) convertToPixel $ (map . map) ord numGrid
        numGrid = chunksOf 4 s
        convertToPixel = (> ord '7')
~~~

Once I could generate the 4x8px half of the pattern, the full pattern could be easily created by just reflecting it over the y-axis. This could be done by mapping a function over the first dimension of the list which would return the contained list concatenated with the reverse of its self.[^pattern-expose]

For testing purposes, I also added a show instance to the AvatarGrid type I used to represent the pattern. The show function would return a visual representation of the pattern using the [full block Unicode symbol](http://www.fileformat.info/info/unicode/char/2588/index.htm). That way it would be easier to tell what the pattern would look like, even before I had implemented the actual image generation.[^pattern-show]

~~~
>>> (generateAvatarGrid . createSeed) "Hello"
██ ██ ██
██    ██
█      █
  █  █  
██    ██
████████
█  ██  █
  █  █  
~~~

Once I had implemented the generation of both avatar colors and patterns from a seed value, I was able to just combine the two into an Avatar datatype. Then I could just create a function which would generate a whole Avatar instance from a given seed value.

Since the avatar patterns start at a size of 8x8px, any image created directly from them would be quite small. In order to increase the size of avatar images I figured that I could write a function which would upscale the size of an avatar by a given scaling factor.

In order to upscale avatar patterns I would need to use a function which would be able to take a given list and scale it up by a given integer factor. Unfortunately, I was unable to find such a function, so I implemented it and exported it as a utility function.[^scale-list]

~~~
>>> scaleList 3 [0, 1]
[0,0,0,1,1,1]
~~~

By making a `scaleAvatar` function available, avatars could easily be scaled up to sizes of powers of two, such as 128x128px and 256x256px.

## Image Generation
Since I finished implementing the generation of avatars, I next needed to work on converting avatars into images. After doing some searching on Hackage for libraries for working with images, I found [JuicyPixels](https://hackage.haskell.org/package/JuicyPixels).

JuicyPixels is a Haskell library which allows you to create and encode images. Most importantly it allows you to be able to be able to create an image by defining a function for getting each pixel of the image and supplying the dimensions of the image.

~~~ haskell
generateImage :: Pixel px => (Int -> Int -> px) -> Int -> Int -> Image px
~~~

In order to convert the avatar pattern into an image, first I needed to convert the two dimensional list of booleans representing the pattern into a two dimensional list of pixels. To be able to do that I would first need to create a function to convert a boolean value and a color into a pixel, and then I could map that over the two dimensional list of booleans to create the desired two dimensional list of pixels.

Since the coloring scheme of the avatar images would consist of colored "True" pixels and white "False" pixels, creating the boolean to pixel conversion function was fairly simple. I would just have it return a white pixel if the boolean is False, and return the pixel color corresponding to the avatar color if the boolean is True.

Once a two dimensional list of pixels could be created, I then needed to turn it into the pixel accessing function required by the `generateImage` function. This was actually fairly simple, and could be accomplished by just returning the correct pixel by using `!!` with both the row and column.

~~~ haskell
getPixel x y = colorGrid !! y !! x
~~~

Then all that was needed by the function was the dimensions of the avatar image. Since all avatar images are all square, the dimensions would both be the same, and could be gotten by taking the length of the two dimensional list of pixels.[^avatar-dimensions]

## Image Encoding
Once I had implemented converting avatars into images, I needed to implement the encoding of avatar images into bytestrings of common image formats, such as PNG and GIF.

At first I decided to prioritize working on getting PNG encoding working first, as that is the main format I designed the library in mind with. Luckily, JuciyPixels comes with a simple function that converts an image into a lazy bytestring.

~~~ haskell
encodePng :: Image a -> ByteString
~~~

From there, I started working on a function which would take in an avatar and a filepath, convert the avatar into a PNG image bytestring, and save the image bytestring to the given filepath. This was mostly straightforward, as it mainly involved calling existing functions and passing values around.

However, once I had implemented saving of avatar images in one format, I decided to try to add support for other image formats as well.

Since the function signature of `encodePng` is fairly general, I figured that I could create a new function `saveAvatarWith` which would allow an image encoding function to be passed in rather than using PNG encoding. I could also provide several common image encoding functions to be used with it.

~~~ haskell
type ImageConversion = (Image PixelRGB8 -> ByteString)

saveAvatarWith :: ImageConversion -> Avatar -> FilePath -> IO ()
~~~

However, I soon found that adding support for other formats would be a little bit more difficult than I originally expected. After looking over the documentation for JuicyPixels I found that the encoding process for several other image formats were a bit more complicated than the process for PNG.

For example, to encode an image using the GIF format, you would either need to just work with greyscale images or supply a color palette for the image.[^image-formats]

~~~ haskell
encodeGifImageWithPalette :: Image Pixel8 -> Palette -> Either String ByteString
~~~

Luckily, however, I was able to eventually find a function `encodeColorReducedGifImage` which would encode RGB images into the GIF format by handling the generation of the color palette.[^gif-encode]

## Testing
To handle testing the library, I decided to use hspec. This is mostly because it is the Haskell testing library that I am most familiar with.[^hspec-choice]

Testing the library was a fairly straightforward process for the most part. Though the main issue I ran into was dealing with test data. I wanted to have the expected output data to be hard-coded, and not generated, so that the tests would be more stable, however this would lead to overly verbose tests.

For example, when testing the `colorFromSeed` function I would need to provide an input seed and the expected output color. However, the seed definitions were some what lengthy and not very expressive.

~~~ haskell
describe "colorFromSeed" $ do
  it "picks a color based on the given seed" $ do
    colorFromSeed (Seed {unSeed = "8b1a9953c4611296a827abf8c47804d7"}) `shouldBe` Grey
~~~

I was able to resolve many instances of this type of issue by assigning the lengthy data to constants at the bottom of the file, and giving them descriptive names. This also helped in the cases in which I used pieces of data multiple times, as I would only need to define them once and just reference them.

~~~ haskell
  describe "colorFromSeed" $ do
    it "picks a color based on the given seed" $ do
      colorFromSeed helloSeed `shouldBe` Grey

helloSeed :: Seed
helloSeed = Seed {unSeed = "8b1a9953c4611296a827abf8c47804d7"}
~~~

This solution worked well for data that wasn't too difficult to enter in a Haskell source file in an expressive way, however, when it came to defining image bytestrings this format wasn't very effective.

I eventually decided that the best way to include the image data to test against, I would include the actual images files and read them in as test data. The issue with this solution was that hspec requires the tests to not use IO, and since I would be reading in the image bytestring from a file I would have to perform IO. In this case I made the controversial decision of using `unsafePerformIO` to load in the image file bytestrings without them being held within the IO monad.[^unsafePerformIO]

However, besides those few issues, testing the library was not too dificult.

## Documentation
The

## Footnotes
[^color-stats]: To see how often specific colors were chosen I mapped the color choosing function over a list of String versions of all of the numbers 1 to a high number such as 10000, and took the length of the list after filtering it down to just the desired color. This is one case where ghci really came in handy.

[^color]: Actually I only realized that this was the cause of the issue when I re-read [the code for the function](https://github.com/ExcaliburZero/pixelated-avatar-generator/blob/bebf6d81b91680bccc4ce7db3e7d739261573282/src/Graphics/Avatars/Pixelated.hs#L31-L43) when I was writing this article. I suppose that's what I get for writing code at 3 AM.

[^color-alg-2]: Originally I tried taking the product of the ord values, however that did not result in a very good color distribution. So I tried summing them instead, and that yielded a good distribution.

[^pattern-type]: I decided to go with a pixelated pattern like the one used by GitHub as opposed to the more geometric patterns used by websites like Techdirt as I thought it would be much easier to implement. That way I would be able to just create the pattern as a two dimensional list and convert it directly into an image.

[^github-pattern]: I only really looked at the GitHub avatar pattern in this detail after I had designed the pattern generation algorithm I would use. Before then I had only really taken note that the avatars were symmetrical on the y-axis. If figured that by not analyzing the patterns too much, I would be able to be more creative in the design of the pattern generation algorithm I would create.

[^md5-coincidence]: The fact that the two both happened to be in amounts of 32 was actually entirely by coincidence. I kind of just lucked out there.

[^map-map]: This is also when I first learned that you could map a function over a two dimensional list by just composing `map` with its self. That's actually kind of cool.

[^pattern-expose]: While I ended up setting up the library such that one would call a function to generate both the avatar color and pattern at the same time, and not need to directly call the pattern generating function `generateAvatarGrid`, I did leave that function exposed. I figured that someone might have some use-case for generating just the pattern. However, I did not expose the underlying functions used for generating the pattern as they were fairly use-case specific.

[^pattern-show]: When I first implemented the show instance, I used the @ symbol to represent the pattern. However, I found that by using a block symbol instead, I would be able to get a better representation of the pattern. Though, the symbol does sometimes cause [visual issues on some applications](https://coveralls.io/builds/7071873/source?filename=src%2FGraphics%2FAvatars%2FPixelated.hs#L267).

[^scale-list]: I thought that `Data.List` would likely have a function for scaling lists up by a given factor since it seemed like a common list operation, however, unfortunately it does not have any such function from what I can tell.

[^avatar-dimensions]: Currently the `convertAvatarToImage` function does not have proper handling for cases in which a non-square avatar is passed into it. I realized this when writing this article and quickly filed an [issue](https://github.com/ExcaliburZero/pixelated-avatar-generator/issues/15) for it. This shouldn't happen if just the avatar generation functions of the library are used, but similar functions created by users of the library could yield avatars that not specifically squares.

[^image-formats]: I was mainly focused on trying to add support for PNG, GIF, and JPEG, as those tend to be the three more commonly used image formats for online images. As of yet, however, I have not added support for JPEG image encoding.

[^gif-encode]: Actually `encodeColorReducedGifImage` returns a `Either String ByteString` rather than just a `ByteString`. I'm actually unsure exactly why it returns an Either rather than just a bytestring. I think this is due to its use of `encodeGifImageWithPalette` which can "return errors if the palette is ill-formed". However, if it is generating the correctly formed (non-Either) palette then there should be no reason that the call to `encodeGifImageWithPalette` should return a Left. To solve this difference in the encoding function I just wrapped the result of the function in [a case statement pulling out the Right value](https://github.com/ExcaliburZero/pixelated-avatar-generator/blob/master/src/Graphics/Avatars/Pixelated.hs#L186-L189). I sure hope that it doesn't ever yield a Left.

[^hspec-choice]: I have worked a little bit with HUnit, but I find it to be more difficult to use than hspec. Specifically, I prefer that hspec allows you to declare and organize tests in an item-test-tree structure, which I find to be a little bit more intuitive and easier to read.

[^unsafePerformIO]: While `unsafePerformIO` is a function which should not really be used in Haskell as it defeats the promise of function purity, I felt that its use in this case was okay for the following reasons. First, it was mainly being used to load in a value that is only being used as expected output in tests and would thus only be treated as if it were a constant that had been manually entered into the source file. Second, the type of IO being performed should not throw any exceptions or cause any output effects. While it is reading in information from files and could thus throw an IOException, as the test image files are in version control and in the Cabal build file as extra source files they should always be present in the correct locations and readable, and thus such exceptions should not be thrown in this case. Third, as I previously noted, including the actual images files and reading them in would be more expressive in terms of showcasing the actual data. It is a bit easier to tell that you are dealing with an image when you are reading in an image file rather than just dealing with a cryptic-looking string.
