---
layout: post
type: article
title:  "Developing a Haskell Library"
author: "Christopher Randall Wells"
image: "/images/first_programming_language.png"
date:   2016-07-19 09:10:00
categories: haskell library avatars
---
Recently I have been working on getting better at writing code in Haskell, and in doing so I have worked on a few different small libraries and applications. One of the more interesting libraries that I have written in this attempt is Pixelated Avatar Generator.

Pixelated Avatar Generator is a Haskell library that I have been working on, which provides functions for generating and saving pixelated avatars for default user avatars for websites, like the ones used by GitHub and Techdirt.

## Starting
To create the initial setup of the library, I used a [custom Stack project template](https://github.com/ExcaliburZero/custom-stack-templates/blob/master/cwells.hsfiles) I put together which includes hspec testing, Travis CI automated testing, and Coveralls.io coverage reports.

From there I started to brainstorm how the library would work. I knew that I wanted a way to be able to generate randomized avatars in a reproducable way that would be easy to test. So I figured that I could set it up so that avatars would be generated by using seed values. That way a random avatar could be generated just by passing in a random seed, while avatars could be reliably generated from given seeds for testing purposes.

In order to work with seed values, I knew that I needed to have some sort of way of standardizing the seed values in order to be able to design an algorithm to use the seed to generate an avatar image. Luckily I had recently watched YouTube user jekor's series on [Haskell From Scratch](https://www.youtube.com/playlist?list=PLxj9UAX4Em-Ij4TKwKvo-SLp-Zbv-hB4B), in which he uses a pure Haskell implementation of an [md5 hash function](https://hackage.haskell.org/package/pureMD5).

Since the md5 hash function can take in a String of a given length and return a 32 digit hexidecimal number, I figured it would be an ideal way to standardize seed values. That way a String could be passed into the md5 function and the seed value would be the resulting standardized number.

~~~
>>> (show . md5 . fromString) "Hello"
"8b1a9953c4611296a827abf8c47804d7"
~~~

## Color Generation
For the avatar images, I decided that each avatar would have a given color from some given set of possible colors. At first I figured that I could make use of the fact that each of the digits in the seed values was hexidecimal, so I decided to have 8 different possible colors.

In order to generate the color I decided to take the first two digits of the seed, average them into one hexidecimal digit, and have each color correspond to two of the possible resulting digits. However, after using ghci to generate a bunch of colors from a list of seeds I found that the statistical distribution of the colors chosen tended to be heavily focused on one specific color. Almost half of the seeds I fould feed into the color choosing function I had writen would yield orange.[^color-stats]

I only later realized that the issue was caused by an incorrect averaging of the hexidecimal digits, as averaged the values returned using `ord` from `Data.Char` and mapped them to the returned values of `ord` on the hexidecimal digits. The values of `ord '9'` and `ord 'a'` are not next to each other.[^color]

Once I noticed the issue with the uneven distribution of colors I decided to come up with a new alorithm for the color choosing function. The algorithm I ended upcoming up with was to take the first two characters of the seed value, sum their `ord` values, and take the modulus 8 of the resulting number and map the resulting digit 0-7 to a color.[^color-alg-2]

~~~ haskell
colorFromSeed :: Seed -> Color
colorFromSeed = genColor . dSum . unSeed
  where twoDigits n = map ord $ take 2 n
        dSum n = foldr (+) 1 $ twoDigits n
        genColor a = [Black .. Yellow] !! (a `mod` 8)
~~~

## Pattern Generation
Once I had handled color generation for avatars, I decided to move on to generating the pattern for the avatar images.

## Footnotes
[^color-stats]: To see how often specific colors were chosen I mapped the color choosing function over a list of String versions of all of the numbers 1 to a high number such as 10000, and took the length of the list after filtering it down to just the deisred color. This is one case where ghci really comes in handy.

[^color]: Actually I only relaized that this was the cause of the issue when I re-read [the code for the function](https://github.com/ExcaliburZero/pixelated-avatar-generator/blob/bebf6d81b91680bccc4ce7db3e7d739261573282/src/Graphics/Avatars/Pixelated.hs#L31-L43) when I was writing this article. I suppose that's what I get for writing code at 3 AM.

[^color-alg-2]: Originally I tried taking the product of the ord values, however that did not result in a very good color distribution. So I tried summing them instead, and that yielded a good distribution.
