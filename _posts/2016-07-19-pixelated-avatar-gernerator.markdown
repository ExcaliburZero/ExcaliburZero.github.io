---
layout: post
type: article
title:  "Developing a Haskell Library"
author: "Christopher Randall Wells"
image: "/images/first_programming_language.png"
date:   2016-07-19 09:10:00
categories: haskell library avatars
---
Recently I have been working on getting better at writing code in Haskell, and in doing so I have worked on a few different small libraries and applications. One of the more interesting libraries that I have written in this attempt is Pixelated Avatar Generator.

Pixelated Avatar Generator is a Haskell library that I have been working on, which provides functions for generating and saving pixelated avatars for default user avatars for websites, like the ones used by GitHub and Techdirt.

## Starting
To create the initial setup of the library, I used a [custom Stack project template](https://github.com/ExcaliburZero/custom-stack-templates/blob/master/cwells.hsfiles) I put together which includes hspec testing, Travis CI automated testing, and Coveralls.io coverage reports.

From there I started to brainstorm how the library would work. I knew that I wanted a way to be able to generate randomized avatars in a reproducable way that would be easy to test. So I figured that I could set it up so that avatars would be generated by using seed values. That way a random avatar could be generated just by passing in a random seed, while avatars could be reliably generated from given seeds for testing purposes.

In order to work with seed values, I knew that I needed to have some sort of way of standardizing the seed values in order to be able to design an algorithm to use the seed to generate an avatar image. Luckily I had recently watched YouTube user jekor's series on [Haskell From Scratch](https://www.youtube.com/playlist?list=PLxj9UAX4Em-Ij4TKwKvo-SLp-Zbv-hB4B), in which he uses a pure Haskell implementation of an [md5 hash function](https://hackage.haskell.org/package/pureMD5).

Since the md5 hash function can take in a String of a given length and return a 32 digit hexidecimal number, I figured it would be an ideal way to standardize seed values. That way a String could be passed into the md5 function and the seed value would be the resulting standardized number.

~~~
>>> (show . md5 . fromString) "Hello"
"8b1a9953c4611296a827abf8c47804d7"
~~~

## Color Generation
For the avatar images, I decided that each avatar would have a given color from some given set of possible colors. At first I figured that I could make use of the fact that each of the digits in the seed values was hexidecimal, so I decided to have 8 different possible colors.

In order to generate the color I decided to take the first two digits of the seed, average them into one hexidecimal digit, and have each color correspond to two of the possible resulting digits. However, after using ghci to generate a bunch of colors from a list of seeds I found that the statistical distribution of the colors chosen tended to be heavily focused on one specific color. Almost half of the seeds I would feed into the color choosing function I had writen would yield orange.[^color-stats]

I only later realized that the issue was caused by an incorrect averaging of the hexidecimal digits, as averaged the values returned using `ord` from `Data.Char` and mapped them to the returned values of `ord` on the hexidecimal digits. The values of `ord '9'` and `ord 'a'` are not next to each other.[^color]

Once I noticed the issue with the uneven distribution of colors I decided to come up with a new alorithm for the color choosing function. The algorithm I ended upcoming up with was to take the first two characters of the seed value, sum their `ord` values, and take the modulus 8 of the resulting number and map the resulting digit 0-7 to a color.[^color-alg-2]

~~~ haskell
colorFromSeed :: Seed -> Color
colorFromSeed = genColor . dSum . unSeed
  where twoDigits n = map ord $ take 2 n
        dSum n = foldr (+) 1 $ twoDigits n
        genColor a = [Black .. Yellow] !! (a `mod` 8)
~~~

## Pattern Generation
Once I had handled color generation for avatars, I decided to move on to generating the pattern for the avatar images. I decided to try to achive a simmilar type of pattern to that used by GitHub in its default avatars.[^pattern-type]

![An example of a default GitHub avatar]({{ site.baseurl }}/images/avatar_github.png)

The type of pattern used in default GitHub avatars starts with a 3x5px pattern which is then reflected over the y axis, such that it overlaps in the middle, resulting in a 5x5px pattern.[^github-pattern]

Instead of using a 5x5px pattern, I decided to try creating an 8x8px pattern. I figured that I could create the pattern by generating a 4x4px pattern and then relfecting it over the y-axis without overlap.

I thought that I would be able to create the 4x8px pattern by creating a list of 32 binary values and then converting that into a grid. I noticed that the seed values, being md5 hashes, were 32 digits in length, so I figured that I could just round them each up or down to a False or True value around 7, and then use those boolean values to represent colored and uncolored pixels in the pattern.[^md5-coincidence] [^map-map]

~~~ haskell
numToGrid :: String -> [[Bool]]
numToGrid s = grid
  where grid = (map . map) convertToPixel $ (map . map) ord numGrid
        numGrid = chunksOf 4 s
        convertToPixel = (> ord '7')
~~~

Once I could generate the 4x8px half of the pattern, the full pattern could be easily created by just relfecting it over the y-axis. This could be done by mapping a function over the first dimension of the list which would return the contained list concatenated with the reverse of its self.[^pattern-expose]

For testing purposes, I also added a show instance to the AvatarGrid type I used to represent the pattern. The show function would return a visual representation of the pattern using the [full block Unicode symbol](http://www.fileformat.info/info/unicode/char/2588/index.htm). That way it would be easier to tell what the pattern would look like, even before I had implemented the actual image generation.[^pattern-show]

~~~
>>> (generateAvatarGrid . createSeed) "Hello"
██ ██ ██
██    ██
█      █
  █  █  
██    ██
████████
█  ██  █
  █  █  
~~~

Once I had implemented the generation of both avatar colors and patterns from a seed value, I was able to just combine the two into an Avatar datatype. Then I could just create a function which would generate a whole Avatar instance from a given seed value.

## Image Generation
Since I finished implementing the generation of avatars, I next needed to work on coverting avatars into images. After doing some searching on Hackage for libraries for working with images, I found [JuicyPixels](https://hackage.haskell.org/package/JuicyPixels).

JuicyPixels is a Haskell library which allows you to create and encode images. Most importantly it allows you to be able to be able to create an image by defining a function for getting each pixel of the image and supplying the dimensions of the image.

~~~ haskell
generateImage :: Pixel px => (Int -> Int -> px) -> Int -> Int -> Image px
~~~

In order to convert the avatar pattern into an image, first I needed to convert the two dimensional list of booleans representing the pattern into a two dimensional list of pixels. To be able to do that I would first need to create a function to convert a boolean value and a color into a pixel, and then I could map that over the two dimensional list of booleans to create the desired two dimensional list of pixels.

Since the coloring scheme of the avatar images would consist of colored "True" pixels and white "False" pixels, creating the boolean to pixel conversion function was fairly simple. I would just have it return a white pixel if the boolean is False, and return the pixel color correpsonding to the avatar color if the boolean is True.

Once a two dimensional list of pixels could be created, I then needed to turn it into the pixel accessing function required bythe `generateImage` function. This was actually fairly simple, and could be accomplished by just returning the correct pixel by using `!!` with both the row and column.

~~~ haskell
getPixel x y = colorGrid !! y !! x
~~~

Then all that was needed by the function was the dimensions of the avatar image. Since all avatar images are all square, the dimensions would both be the same, and could be gotten by taking the length of the two dimensional list of pixels.[^avatar-dimensions]

## Footnotes
[^color-stats]: To see how often specific colors were chosen I mapped the color choosing function over a list of String versions of all of the numbers 1 to a high number such as 10000, and took the length of the list after filtering it down to just the deisred color. This is one case where ghci really came in handy.

[^color]: Actually I only relaized that this was the cause of the issue when I re-read [the code for the function](https://github.com/ExcaliburZero/pixelated-avatar-generator/blob/bebf6d81b91680bccc4ce7db3e7d739261573282/src/Graphics/Avatars/Pixelated.hs#L31-L43) when I was writing this article. I suppose that's what I get for writing code at 3 AM.

[^color-alg-2]: Originally I tried taking the product of the ord values, however that did not result in a very good color distribution. So I tried summing them instead, and that yielded a good distribution.

[^pattern-type]: I decided to go with a pixelated pattern like the one used by GitHub as opposed to the more geometric patterns used by websites like Techdirt as I thought it would be much easier to implement. That way I would be able to just create the pattern as a two dimensional list and convert it directly into an image.

[^github-pattern]: I only really looked at the GitHub avatar pattern in this detail after I had designed the pattern generation algorithm I would use. Before then I had only really taken note that the avatars were symmetrical on the y-axis. If figured that by not analyzing the patterns too much, I would be able to be more creative in the design of the pattern generation algorithm I would create.

[^md5-coincidence]: The fact that the two both happened to be in amounts of 32 was actually entirely by coincidence. I kind of just lucked out there.

[^map-map]: This is also when I first learned that you could map a function over a two dimensional list by just composing `map` with its self. That's actually kind of cool.

[^pattern-expose]: While I ended up setting up the library such that one would call a function to generate both the avatar colorand pattern at the same time, and not need to directly call the pattern generating function `generateAvatarGrid`, I did leave that function exposed. I figured that someone might have some usecase for generating just the pattern. However, I did not expose the underlying functions used for generating the pattern as they were fairly usecase specific.

[^pattern-show]: When I first implemented the show instance, I used the @ symbol to represent the pattern. However, I found that by using a block symbol instead, I would be able to get a better representation of the pattern. Though, the symbol does sometimes cause [visual issues on some applications](https://coveralls.io/builds/7071873/source?filename=src%2FGraphics%2FAvatars%2FPixelated.hs#L267).

[^avatar-dimensions]: Currently the `convertAvatarToImage` function does not have proper handling for cases in which a non-square avatar is passed into it. I realized this when writing this article and quickly filed an [issue](https://github.com/ExcaliburZero/pixelated-avatar-generator/issues/15) for it. This shouldn't happen if just the avatar generation functions of the library are used, but simmilar functions created by users of the library could yield avatars that not specifically squares.
