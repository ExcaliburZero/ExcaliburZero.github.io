---
layout: post
type: article
title:  "Developing a Haskell Library"
author: "Christopher Randall Wells"
image: "/images/developing_haskell_library.png"
date:   2016-07-19 09:10:00
categories: haskell library avatars
---
Recently I have been working on getting better at writing code in Haskell, and in doing so I have worked on a few different small libraries and applications. One of the more interesting libraries that I have written in this attempt is [Pixelated Avatar Generator](https://hackage.haskell.org/package/pixelated-avatar-generator).

Pixelated Avatar Generator is a Haskell library that I have been working on, which provides functions for generating and saving pixelated avatars to serve as default user avatars for websites, similar to the ones used by GitHub and Techdirt.

## Starting
To create the initial setup of the library, I used a [custom Stack project template](https://github.com/ExcaliburZero/custom-stack-templates/blob/master/cwells.hsfiles) I put together which includes hspec testing, Travis CI automated testing, and Coveralls.io coverage reports.

From there I started to brainstorm how the library would work. I knew that I wanted a way to be able to generate randomized avatars in a reproducible way that would be easy to test. So I figured that I could set it up so that avatars would be generated by using seed values. That way a random avatar could be generated just by passing in a random seed, while avatars could be reliably generated from given seeds for testing purposes.

In order to work with seed values, I knew that I needed to have some sort of way of standardizing the seed values in order to be able to design an algorithm to use the seed to generate an avatar image. Luckily I had recently watched YouTube user jekor's series on [Haskell From Scratch](https://www.youtube.com/playlist?list=PLxj9UAX4Em-Ij4TKwKvo-SLp-Zbv-hB4B), in which he uses a pure Haskell implementation of an [md5 hash function](https://hackage.haskell.org/package/pureMD5).

Since the md5 hash function can take in a String of a given length and return a 32 digit hexadecimal number, I figured it would be an ideal way to standardize seed values. That way a String could be passed into the md5 function and the seed value would be the resulting standardized number.

~~~
>>> (show . md5 . fromString) "Hello"
"8b1a9953c4611296a827abf8c47804d7"
~~~

## Color Choosing
For the avatar images, I decided that each avatar would have a main color which would be used for the pattern of the avatar, and a white background. The main color would be a given color from some given set of possible colors. At first I figured that I could make use of the fact that each of the digits in the seed values was hexadecimal, so I decided to have 8 different possible colors.[^8-colors]

In order to choose the color for an avatar I decided to take the first two digits of the seed, average them into one hexadecimal digit, and have each color correspond to two of the possible resulting digits. However, after using ghci to generate a bunch of colors from a list of seeds I found that the statistical distribution of the colors chosen tended to be heavily focused on one specific color. Almost half of the seeds I would feed into the color choosing function I had written would yield orange.[^color-stats]

I only later realized that the issue was caused by an incorrect averaging of the hexadecimal digits. I took the values returned by using `ord` from `Data.Char` on the first two digits, averaged them together, and then mapped the resulting "digit" to the returned values of `ord` on the hexadecimal digits. However, this resulted in some issues as there is a notable gap between the values of `ord '9'` and `ord 'a'`.[^color]

Once I noticed the issue with the uneven distribution of colors, I decided to come up with a new algorithm for the color choosing function. The algorithm I ended upcoming up with was to take the first two characters of the seed value, sum their `ord` values plus one, take the modulus 8 of the resulting number, and map the resulting digit 0-7 to a color.[^color-alg-2] [^color-sum]

~~~ haskell
colorFromSeed :: Seed -> Color
colorFromSeed = genColor . dSum . unSeed
  where twoDigits n = map ord $ take 2 n
        dSum n = foldr (+) 1 $ twoDigits n
        genColor a = [Black .. Yellow] !! (a `mod` 8)
~~~

## Pattern Generation
Once I had implemented color choosing for avatars, I decided to move on to designing an algorithm for generating the patterns for avatar images. I decided to try to achieve a similar type of pattern to the patterns used by GitHub in its default avatars.[^pattern-type]

![An example of a default GitHub avatar]({{ site.baseurl }}/images/avatar_github.png)

After looking over a few default GitHub avatars, I found that the patterns start with a 3x5 pattern which is then reflected over the y axis, such that it overlaps in the middle, resulting in a 5x5 pattern. A 1/2 width border is then applied around the 5x5 pattern to create a 6x6 pattern.[^github-pattern]

Instead of using a 6x6 bordered pattern, I decided to try creating an 8x8 pattern with no border. I figured that I could create the pattern by generating a 4x8 pattern and then reflecting it over the y-axis without overlap.[^8-pattern]

I figured that I would be able to create the 4x8 pattern by creating a list of 32 binary values and then convert it into a grid. I noticed that the seed values, being hexadecimal md5 hashes, were 32 digits in length, so I figured that I could just round them each up or down to a False or True value around 7, and then use those boolean values to represent colored and uncolored pixels in the pattern.[^md5-coincidence] [^map-map]

~~~ haskell
numToGrid :: String -> [[Bool]]
numToGrid s = grid
  where grid = (map . map) (convertToPixel . ord) numGrid
        numGrid = chunksOf 4 s
        convertToPixel = (> ord '7')
~~~

Once I could generate the 4x8 half of the pattern, the full pattern could be easily created by just reflecting it over the y-axis. This could be done by mapping a function over the first dimension of the list which would return the contained list concatenated with the reverse of its self.[^pattern-expose]

For testing purposes, I also added a show instance to the AvatarGrid type I used to represent the pattern. The show function would return a visual representation of the pattern using the [full block Unicode symbol](http://www.fileformat.info/info/unicode/char/2588/index.htm). That way it would be easier to tell what the pattern would look like, even before I had implemented the actual image generation.[^pattern-show]

~~~
>>> (generateAvatarGrid . createSeed) "Hello"
██ ██ ██
██    ██
█      █
  █  █  
██    ██
████████
█  ██  █
  █  █  
~~~

Once I had implemented the generation of both avatar colors and patterns from a seed value, I was able to just combine the two into an Avatar datatype. Then I could just create a function which would generate a whole Avatar instance from a given seed value.

Since the avatar patterns start at a size of 8x8, any image created directly from them would be quite small. In order to increase the size of avatar images I figured that I could write a function which would upscale the size of an avatar by a given scaling factor.

In order to upscale avatar patterns I would need to use a function which would be able to take a given list and scale it up by a given integer factor. Unfortunately, I was unable to find such a function, so I implemented it and exported it as a utility function.[^scale-list]

~~~
>>> scaleList 3 [0, 1]
[0,0,0,1,1,1]
~~~

By making a `scaleAvatar` function available, avatars could easily be scaled up to common sizes of powers of two, such as 128x128px and 256x256px.

## Image Generation
Since I finished implementing the generation of avatars, I next needed to work on converting avatars into images. After doing some searching on Hackage for libraries for working with images, I found [JuicyPixels](https://hackage.haskell.org/package/JuicyPixels).

JuicyPixels is a Haskell library which allows you to create and encode images. Most importantly it allows you to be able to be able to create an image by defining a function for getting each pixel of the image and supplying the dimensions of the image.

~~~ haskell
generateImage :: Pixel px => (Int -> Int -> px) -> Int -> Int -> Image px
~~~

In order to convert the avatar pattern into an image, first I needed to convert the two dimensional list of booleans representing the pattern into a two dimensional list of pixels. To be able to do that I would first need to create a function to convert a boolean value and a color into a pixel, and then I could map that over the two dimensional list of booleans to create the desired two dimensional list of pixels.

Since the coloring scheme of the avatar images would consist of colored "True" pixels and white "False" pixels, creating the boolean to pixel conversion function was fairly simple. I would just have it return a white pixel if the boolean is False, and return the pixel color corresponding to the avatar color if the boolean is True.

Once a two dimensional list of pixels could be created, I then needed to turn it into the pixel accessing function required by the `generateImage` function. This was actually fairly simple, and could be accomplished by just returning the correct pixel by using `!!` with both the row and column.

~~~ haskell
getPixel x y = colorGrid !! y !! x
~~~

Then all that was needed by the function was the dimensions of the avatar image. Since all avatar images are all square, the dimensions would both be the same, and could be gotten by taking the length of the two dimensional list of pixels.[^avatar-dimensions]

## Image Encoding
Once I had implemented converting avatars into images, I needed to implement the encoding of avatar images into bytestrings of common image formats, such as PNG and GIF.

At first I decided to prioritize working on getting PNG encoding working first, as that is the main format I designed the library in mind with. Luckily, JuciyPixels comes with a simple function that converts an image into a lazy bytestring.

~~~ haskell
encodePng :: Image a -> ByteString
~~~

From there, I started working on a function which would take in an avatar and a filepath, convert the avatar into a PNG image bytestring, and save the image bytestring to the given filepath. This was mostly straightforward, as it mainly involved calling existing functions and passing values around.

However, once I had implemented saving of avatar images in one format, I decided to try to add support for other image formats as well.

Since the function signature of `encodePng` is fairly general, I figured that I could create a new function `saveAvatarWith` which would allow an image encoding function to be passed in rather than using PNG encoding. I could also provide several common image encoding functions to be used with it.

~~~ haskell
type ImageConversion = (Image PixelRGB8 -> ByteString)

saveAvatarWith :: ImageConversion -> Avatar -> FilePath -> IO ()
~~~

However, I soon found that adding support for other formats would be a little bit more difficult than I originally expected. After looking over the documentation for JuicyPixels I found that the encoding process for several other image formats were a bit more complicated than the process for PNG.

For example, to encode an image using the GIF format, you would either need to just work with greyscale images or supply a color palette for the image.[^image-formats]

~~~ haskell
encodeGifImageWithPalette :: Image Pixel8 -> Palette -> Either String ByteString
~~~

Luckily, however, I was able to eventually find a function `encodeColorReducedGifImage` which would encode RGB images into the GIF format by handling the generation of the color palette.[^gif-encode]

## Testing
To handle testing the library, I decided to use hspec. This is mostly because it is the Haskell testing library that I am most familiar with.[^hspec-choice]

Testing the library was a fairly straightforward process for the most part. Though the main issue I ran into was dealing with test data. I wanted to have the expected output data to be hard-coded, and not generated, so that the tests would be more stable, however this would lead to overly verbose tests.

For example, when testing the `colorFromSeed` function I would need to provide an input seed and the expected output color. However, the seed definitions were some what lengthy and not very expressive.

~~~ haskell
describe "colorFromSeed" $ do
  it "picks a color based on the given seed" $ do
    colorFromSeed (Seed {unSeed = "8b1a9953c4611296a827abf8c47804d7"}) `shouldBe` Grey
~~~

I was able to resolve many instances of this type of issue by assigning the lengthy data to constants at the bottom of the file, and giving them descriptive names. This also helped in the cases in which I used pieces of data multiple times, as I would only need to define them once and just reference them.

~~~ haskell
  describe "colorFromSeed" $ do
    it "picks a color based on the given seed" $ do
      colorFromSeed helloSeed `shouldBe` Grey

helloSeed :: Seed
helloSeed = Seed {unSeed = "8b1a9953c4611296a827abf8c47804d7"}
~~~

This solution worked well for data that wasn't too difficult to enter in a Haskell source file in an expressive way, however, when it came to defining image bytestrings this format wasn't very effective.

I eventually decided that the best way to include the image data to test against, I would include the actual images files and read them in as test data. The issue with this solution was that hspec requires the tests to not use IO, and since I would be reading in the image bytestring from a file I would have to perform IO. In this case I made the controversial decision of using `unsafePerformIO` to load in the image file bytestrings without them being held within the IO monad.[^unsafePerformIO]

However, besides those few issues, testing the library was not too difficult.

## Executable
In addition to the library, I decided to make a simple executable program for generating avatar images. In doing so, I would be able to test out how the library would be used, in addition to providing a language-agnostic interface to the avatar generating capabilities of the library.[^language-agnostic]

At first I began working on a simple program which would take in a filepath and a seed string, and generate an avatar image from the seed string and save it to the given filepath. I also made use of the Show instance for the Avatar type in order to print out a text representation of the generated avatar image.[^old-executable]

~~~
$ pixelated-avatar-generator image.png "Hello, World"
Creating avatar at image.png
Grey
█ ████ █

  ████  
█  ██  █
████████
█ █  █ █
█      █
████████
Successfully created avatar, and saved it to image.png
~~~

Once I had finished implementing the basic avatar generating functionality in the program, I decided to move on to adding other features such as generating multiple avatars and once and allowing the program to generate random avatars.

However, I realized that the simple program structure I had created would be insufficient for dealing with command flags that would be used to specify the use of such functionality. I figured that it would be best to change the program to use a proper command line interface Haskell library.

After doing some searching on Hackage for command flag parsing libraries, I eventually found [cli](https://hackage.haskell.org/package/cli). Cli allows one to handle command flags using a fairly straightforward DSL, in addition to also providing other common functionality that many cli applications use such as generating help info and command line visual effects.

~~~haskell
main = defaultMain $ do
    programName "test-cli"
    programDescription "test CLI program"
    flagA    <- flag $ FlagShort 'a' <> FlagLong "aaa"
    allArgs  <- remainingArguments "FILE"
    action $ \toParam -> do
        putStrLn $ "using flag A : " ++ show (toParam flagA)
        putStrLn $ "args: " ++ show (toParam allArgs)
~~~

So I started to rewrite the executable using the cli library. Luckily, the DSL used by the library was fairly easy to pickup for the most part. Most of the difficulty in writing the executable was in its design, rather than in working with the library.

At first, I figured that I would setup the executable so that the user would supply a series of image paths and seed strings, and would be able to set a flag to have the application use random seed strings instead. However, I figured that this would likely seem to the user like an odd method of specifying images, so I decided to instead just have the executable use random seed strings. That way the user would just have to specify the image paths where they would want random avatars to be saved to.

~~~
$ pixelated-avatar-generator image1.png image2.png
Successfully created 2 avatars.
~~~

Next I needed to come up with a way to generate random seed strings. Luckily, this ended up being a fairly simple process. Previous to working on this application, I had not worked with random number generation in Haskell. After doing some searching I found the `System.Random` library. After looking over the documentation I found that using `randomIO` would help.

Using `randomIO`, I would be able to generate a random number, then in order to generate the seed string I could just convert the generated number into a String.[^random-number] [^random-string]

~~~haskell
>>> show <$> (randomIO :: IO Double)
"0.18637400040717844"
~~~

Since I then had a way to generate random seed strings, I was then able to setup the executable to generate random avatar images at user-specifed filepaths.

### Custom Scaling
Next I decided to add a flag to the executable that would allow the user to change the size of the avatar images that are generated. By default, I had the program generate images at a size of 256x256px, however this could be changed by using a user-specified scaling factor. The scaling factor would then be multiplied by 8 to get the resulting image size, since this ishow the library handles image sizing.

Using the cli library, handling the flag parsing was not too dificult. The library allows one to create command flags by specifying what the flags should be called, and whether or not they take in a parameter. It also allows you to give a description of the flag which is included in the program help information. The library also requires you to give a parameter parser if the flag takes in a parameter.

~~~
flagS <- flagParam
  (FlagLong "scaling-factor" <> FlagDescription scalingFlagDescription)
  (FlagRequired scaleParser)
~~~

Since the scaling factor would need a parameter to get the user's desired custom scaling factor, I would need to put together a parser to parse valid scaling factors. Considering how the library handles avatar scaling, a valid scaling factor would have to be an integer value that is greater than zero.[^param-parsers]

~~~haskell
scaleParser :: String -> Either String Int
~~~

I decided to approach implementing the parser, by first checking to make sure that the given string is a valid positive integer, and then use the `read :: String -> Int` function to obtain the actual value.

First I would need to check if the given string was a natural number (0,1..). I could do this easily by checking if all of the the characters in the string are digits using the `isDigit` function from `Data.Char`. This would rule out all non-numbers, decimal values, and negative integers.

After that I would need to check if the string was zero. In order to determine if the string is zero, I would have to check if all of the characters in the string are zero. That would rule out a literal "0" string as well as any zero string that has additional leading zeroes "000".

If the given string is a natural number and is not zero, then I would just return the value given by parsing the string with `read :: String -> Int`.

~~~haskell
scaleParser :: String -> Either String Int
scaleParser string
    | isPosInt string = Right ((read :: String -> Int) string)
    | otherwise       = Left "The given String is not a positive integer"
  where
    isPosInt s   = isNaturalNum s && isNotZero s
    isNaturalNum = all isDigit
    isNotZero s  = not $ all (== '0') s
~~~

Once I had implemented the scaling factor parser, I was able to set it to be used to get a custom scaling factor when the user includes the `--scaling-factor` flag.[^scaling-factor-example]

~~~bash
$ pixelated-avatar-generator image1.png image2.png --scaling-factor=4
Successfully created 2 avatars.
~~~

Then, within the body of the executable I would be able to use a custom scaling factor if the user gave one, or use a default scaling factor if they did not provide a scaling factor.[^to-param] [^default-scaling-factor]

~~~haskell
let scalingFactor = fromMaybe defaultScalingFactor (toParam flagS)
~~~

Since I had created a function that would create and save a random avatar using a given scaling factor to a given filepath, I was able to just perform a parital application using the scaling factor and map the resulting function over the list of image paths in order to generate all of the specified images.

~~~
_ <- map (saveRandomAvatar scalingFactor) paths
~~~

### Concurrent Image Creation


# Conclusion
The

## Footnotes
[^8-colors]: I could have also gone with having 16 possible colors, however I figured that 16 would be a bit too many colors to have. So I decided to go with 8 colors instead, as it seemed like a reasonable number of colors, and is a divisor of 16.

[^color-stats]: To see how often specific colors were chosen I mapped the color choosing function over a list of String versions of all of the numbers 1 to a high number such as 10000, and took the length of the list after filtering it down to just the desired color. This is one case where ghci really came in handy.

[^color]: Actually I only realized that this was the cause of the issue when I re-read [the code for the function](https://github.com/ExcaliburZero/pixelated-avatar-generator/blob/bebf6d81b91680bccc4ce7db3e7d739261573282/src/Graphics/Avatars/Pixelated.hs#L31-L43) when I was writing this article. I suppose that's what I get for writing code at 3 AM.

[^color-alg-2]: Originally I tried taking the product of the ord values, however that did not result in a very good color distribution. So I tried summing them instead, and that yielded a good distribution.

[^color-sum]: The additional one included in the sum of the digits was actually just leftover from when I was attempting to take the product of the digits. I just forgot to replace the one with a zero when I changed the algorithm to use the sum instead. Though the extra one doesn't alter the algorithm too much, as it just shifts the color mapping over by one. 

[^pattern-type]: I decided to go with a pixelated pattern like the one used by GitHub as opposed to the more geometric patterns used by websites like Techdirt, as I thought it would be much easier to implement. That way I would be able to just create the pattern as a two dimensional list and convert it directly into an image.

[^github-pattern]: I only really looked at the GitHub avatar pattern in this detail after I had designed the pattern generation algorithm I would use. Before then I had only really taken note that the avatars were symmetrical on the y-axis. If figured that by not analyzing the patterns too much, I would be able to be more creative in the design of the pattern generation algorithm I would create.

[^8-pattern]: I decided to use an 8x8px pattern because it would provide sufficient detail, while also being a power of two. Before doing the algorithm design, I tried manually creating some patterns using GIMP, and I found that using 8x8px patterns would work well.

[^md5-coincidence]: The fact that the two both happened to be in amounts of 32 was actually entirely by coincidence. I kind of just lucked out there.

[^map-map]: This is also when I first learned that you could map a function over a two dimensional list by just composing `map` with its self. That's actually kind of cool.

[^pattern-expose]: While I ended up setting up the library such that one would call a function to generate both the avatar color and pattern at the same time, and not need to directly call the pattern generating function `generateAvatarGrid`, I did leave that function exposed. I figured that someone might have some use-case for generating just the pattern. However, I did not expose the underlying functions used for generating the pattern as they were fairly use-case specific.

[^pattern-show]: When I first implemented the show instance, I used the @ symbol to represent the pattern. However, I found that by using a block symbol instead, I would be able to get a better representation of the pattern. Though, the symbol does sometimes cause visual issues on some applications.[^coveralls-fix]

[^coveralls-fix]: Originially I included a link to a Coveralls.io coverage report on the library which displayed question mark within diamond symbols in place of the block symbol. However, at some point between when I wrote the footnote and when I went back over the link while editing this article, Coveralls apparently fixed this display issue.

[^scale-list]: I thought that `Data.List` would likely have a function for scaling lists up by a given factor since it seemed like a common list operation, however, unfortunately it does not have any such function from what I can tell.

[^avatar-dimensions]: Currently the `convertAvatarToImage` function does not have proper handling for cases in which a non-square avatar is passed into it. I realized this when writing this article and quickly filed an [issue](https://github.com/ExcaliburZero/pixelated-avatar-generator/issues/15) for it. This shouldn't happen if just the avatar generation functions of the library are used, but similar functions created by users of the library could yield avatars that not specifically squares.

[^image-formats]: I was mainly focused on trying to add support for PNG, GIF, and JPEG, as those tend to be the three more commonly used image formats for online images. As of yet, however, I have not added support for JPEG image encoding.

[^gif-encode]: Actually `encodeColorReducedGifImage` returns a `Either String ByteString` rather than just a `ByteString`. I'm actually unsure exactly why it returns an Either rather than just a bytestring. I think this is due to its use of `encodeGifImageWithPalette` which can "return errors if the palette is ill-formed". However, if it is generating the correctly formed (non-Either) palette then there should be no reason that the call to `encodeGifImageWithPalette` should return a Left. To solve this difference in the encoding function I just wrapped the result of the function in [a case statement pulling out the Right value](https://github.com/ExcaliburZero/pixelated-avatar-generator/blob/master/src/Graphics/Avatars/Pixelated.hs#L186-L189). I sure hope that it doesn't ever yield a Left.

[^hspec-choice]: I have worked a little bit with HUnit, but I find it to be more difficult to use than hspec. Specifically, I prefer that hspec allows you to declare and organize tests in an item-test-tree structure, which I find to be a little bit more intuitive and easier to read. Also, at the time I wrote the library I did not really have any understanding of proprty-based testing, so thus I did not use any proprty testing libraries such as QuickCheck.

[^unsafePerformIO]: While `unsafePerformIO` is a function which should not really be used in Haskell as it defeats the promise of function purity, I felt that its use in this case was okay for the following reasons. First, it was mainly being used to load in a value that is only being used as expected output in tests and would thus only be treated as if it were a constant that had been manually entered into the source file. Second, the type of IO being performed should not throw any exceptions or cause any output effects. While it is reading in information from files and could thus throw an IOException, as the test image files are in version control and in the Cabal build file as extra source files they should always be present in the correct locations and readable, and thus such exceptions should not be thrown in this case. Third, as I previously noted, including the actual images files and reading them in would be more expressive in terms of showcasing the actual data. It is a bit easier to tell that you are dealing with an image when you are reading in an image file rather than just dealing with a cryptic-looking string. If there is a better way of handling IO in hpsec, please let me know.

[^language-agnostic]: If figured that by offering an executable, developers using languages other than Haskell would be able to make use of the functionality of the library via the command line.

[^old-executable]: The source code for the original executable can be found in the [old project commits on GitHub](https://github.com/ExcaliburZero/pixelated-avatar-generator/blob/b57669fece575cc7d576e0a8f5f86a1f3c99ed5b/app/Main.hs).

[^random-number]: I'm not very familiar with `System.Random`, but I'd assume that like most random number generation standard libraries in various languages, it generates psuedo-random numbers. Though, I figured that this would not matter much in this use case, as it would not matter if the generated avatar images could be predicted. As long as the generated numbers would be different from each other, even when generated realivtively quickly from one another, then there would be no issue.

[^random-string]: One possible issue that this method of generating random strings is that all of the strings are doubles, and thus consist only of digits and decimal points. This could be an issue with some usages of random strings.

[^param-parsers]: Unfortunately, the cli library does not provide commonly used parameter parsers to use in flag specifications.I likely could have looked around for libraries that provide common parsers to find a parser that would work for my cases. However I figured that the parser would not be too diffucult to implement, so I just went ahead and implemented it.

[^scaling-factor-example]: Looking back on this example run of the executable, I probably should have included some sort of notice that it properly noticed and used the custom scaling factor. For example, I could have had it instead output `Successfully created 2 avatars with a scaling factor of 4.`.

[^to-param]: In this code sample, the `toParam` value is a function passed into the executable's "action" function. It takes in an application flag or parameter and converts it into the corresponding value. In this case, since the `--scaling-factor` flag is optional, the use of `toParam flagS` returns a `Maybe Int`. On second thought, I should probably give `flagS` a more descriptive name.

[^default-scaling-factor]: I actually defined the default scaling factor as a value in the scope of the executable module. Originally I had included it as a regular value within the `scalingFactor` definition line, however I found that it was not immediately obvious as to what the value's purpose was, so I decided to store it in a more descriptive value and move it into the module scope so that it would be easier to locate.
