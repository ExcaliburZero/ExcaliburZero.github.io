---
layout: post
type: article
title:  "Developing a Haskell Library"
author: "Christopher Randall Wells"
image: "/images/first_programming_language.png"
date:   2016-07-19 09:10:00
categories: haskell library avatars
---
Recently I have been working on getting better at writing code in Haskell, and in doing so I have worked on a few different small libraries and applications. One of the more interesting libraries that I have written in this attempt is Pixelated Avatar Generator.

Pixelated Avatar Generator is a Haskell library that I have been working on, which provides functions for generating and saving pixelated avatars for default user avatars for websites, like the ones used by GitHub and Techdirt.

## Starting
To create the initial setup of the library, I used a [custom Stack project template](https://github.com/ExcaliburZero/custom-stack-templates/blob/master/cwells.hsfiles) I put together which includes hspec testing, Travis CI automated testing, and Coveralls.io coverage reports.

From there I started to brainstorm how the library would work. I knew that I wanted a way to be able to generate randomized avatars in a reproducable way that would be easy to test. So I figured that I could set it up so that avatars would be generated by using seed values. That way a random avatar could be generated just by passing in a random seed, while avatars could be reliably generated from given seeds for testing purposes.

In order to work with seed values, I knew that I needed to have some sort of way of standardizing the seed values in order to be able to design an algorithm to use the seed to generate an avatar image. Luckily I had recently watched YouTube user jekor's series on [Haskell From Scratch](https://www.youtube.com/playlist?list=PLxj9UAX4Em-Ij4TKwKvo-SLp-Zbv-hB4B), in which he uses a pure Haskell implementation of an [md5 hash function](https://hackage.haskell.org/package/pureMD5).

Since the md5 hash function can take in a String of a given length and return a 32 digit hexidecimal number, I figured it would be an ideal way to standardize seed values. That way a String could be passed into the md5 function and the seed value would be the resulting standardized number.

~~~
>>> (show . md5 . fromString) "Hello"
"8b1a9953c4611296a827abf8c47804d7"
~~~

## Color Generation
For the avatar images, I decided that each avatar would have a given color from some given set of possible colors. At first I figured that I could make use of the fact that each of the digits in the seed values was hexidecimal, so I decided to have 8 different possible colors.

In order to generate the color I decided to take the first two digits of the seed, average them into one hexidecimal digit, and have each color correspond to two of the possible resulting digits. However, after using ghci to generate a bunch of colors from a list of seeds I found that the statistical distribution of the colors chosen tended to be heavily focused on one specific color. Almost half of the seeds I fould feed into the color choosing function I had writen would yield orange.[^color-stats]

I only later realized that the issue was caused by an incorrect averaging of the hexidecimal digits, as averaged the values returned using `ord` from `Data.Char` and mapped them to the returned values of `ord` on the hexidecimal digits. The values of `ord '9'` and `ord 'a'` are not next to each other.[^color]

Once I noticed the issue with the uneven distribution of colors I decided to come up with a new alorithm for the color choosing function. The algorithm I ended upcoming up with was to take the first two characters of the seed value, sum their `ord` values, and take the modulus 8 of the resulting number and map the resulting digit 0-7 to a color.[^color-alg-2]

~~~ haskell
colorFromSeed :: Seed -> Color
colorFromSeed = genColor . dSum . unSeed
  where twoDigits n = map ord $ take 2 n
        dSum n = foldr (+) 1 $ twoDigits n
        genColor a = [Black .. Yellow] !! (a `mod` 8)
~~~

## Pattern Generation
Once I had handled color generation for avatars, I decided to move on to generating the pattern for the avatar images. I decided to try to achive a simmilar type of pattern to that used by GitHub in its default avatars.

![An example of a default GitHub avatar]({{ site.baseurl }}/images/avatar_github.png)

The type of pattern used in default GitHub avatars starts with a 3x5px pattern which is then reflected over the y axis, such that it overlaps in the middle, resulting in a 5x5px pattern.[^github-pattern]

Instead of using a 5x5px pattern, I decided to try creating an 8x8px pattern. I figured that I could create the pattern by generating a 4x4px pattern and then relfecting it over the y-axis without overlap.

I thought that I would be able to create the 4x8px pattern by creating a list of 32 binary values and then converting that into a grid. I noticed that the seed values, being md5 hashes, were 32 digits in length, so I figured that I could just round them each up or down to a False or True value around 7, and then use those boolean values to represent colored and uncolored pixels in the pattern.[^md5-coincidence] [^map-map]

~~~ haskell
numToGrid :: String -> [[Bool]]
numToGrid s = grid
  where grid = (map . map) convertToPixel $ (map . map) ord numGrid
        numGrid = chunksOf 4 s
        convertToPixel = (> ord '7')
~~~

## Footnotes
[^color-stats]: To see how often specific colors were chosen I mapped the color choosing function over a list of String versions of all of the numbers 1 to a high number such as 10000, and took the length of the list after filtering it down to just the deisred color. This is one case where ghci really comes in handy.

[^color]: Actually I only relaized that this was the cause of the issue when I re-read [the code for the function](https://github.com/ExcaliburZero/pixelated-avatar-generator/blob/bebf6d81b91680bccc4ce7db3e7d739261573282/src/Graphics/Avatars/Pixelated.hs#L31-L43) when I was writing this article. I suppose that's what I get for writing code at 3 AM.

[^color-alg-2]: Originally I tried taking the product of the ord values, however that did not result in a very good color distribution. So I tried summing them instead, and that yielded a good distribution.

[^github-pattern]: I only really looked at the GitHub avatar pattern in this detail after I had designed the pattern generation algorithm I would use. Before then I had only really taken note that the avatars were symmetrical on the y-axis. If figured that by not analyzing the patterns too much, I would be able to be more creative in the design of the pattern generation algorithm I would create.

[^md5-coincidence]: The fact that the two both happened to be in amounts of 32 was actually entirely by coincidence. I kind of just lucked out there.

[^map-map]: This is also when I learned that you could map a function over a two dimensional list by just composing `map` with its self. That's actually kind of cool.
